<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>THE SOLID SERIES - Open Closed Principle</title>
        <link rel="stylesheet" href="./css/reveal.css">
        <link rel="stylesheet" href="./css/theme/black.css" id="theme">
        <link rel="stylesheet" href="./css/highlight/zenburn.css">
        <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print">

    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">

# THE SOLID SERIES ‚Ñ¢Ô∏è
### Open closed principle
</script></section><section  data-markdown><script type="text/template">
<img width="250" height="400" src="//mracos.me/images/ec11e49de372d736c6ac3b6153dae046.jpg" />

github: [@mracos](https://github.com/mracos)

twitter: [@mractos](https://twitter.com/mractos)
</script></section><section  data-markdown><script type="text/template">
- o que √©?
- por que foi criado?
- exemplinhos
</script></section><section  data-markdown><script type="text/template">
‚ö†Ô∏è

essa talk √© um beta, ela vem sem garantias e n√£o me responsabilizo se as coisas n√£o funcionarem,
sua casa pegar fogo ou o maluco do U2 vier cantar na sua casa

‚ö†Ô∏è
</script></section><section ><section data-markdown><script type="text/template">
- o que √©?
</script></section><section data-markdown><script type="text/template">
Segundo a [wikipedia](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) ‚Ñ¢Ô∏è:

> "software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification"
</script></section><section data-markdown><script type="text/template">
Significa que tais entidades devem permitir que seu comportamento seja extendido **sem alterar o c√≥digo fonte**

<aside class="notes"><ul>
<li>foque em <strong>extendido</strong> e n√£o necessariamente alterado</li>
</ul>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
- por que foi criado? (e por quem?)
- exemplinhos
</script></section><section data-markdown><script type="text/template">
<ul>

  <li>qual a forma mais f√°cil de extender um software?</li>
  <li class="fragment">Modificando a implementa√ß√£o atual, certo?</li>
  <li class="fragment">Adicionando um if num m√©todo, ou algo assim</li>
  <li class="fragment">Mas ai depois isso pode ir crescendo e indo ficando complicado de manter</li>
</ul>
</script></section><section data-markdown><script type="text/template">
```ruby
class Square; attr_acessor :color, :height, :width; end
class Circle; attr_acessor :color, :radius; end

class Drawer
  def draw(shapes)
    shapes.each do |shape|
      case shape.class
        when Square then draw_square(square)
        when Circle then draw_circle(circle)
      end
    end
  end

  def draw_square(square)
    "#{square.height} x #{square.width}: #{square.color}"
  end

  def draw_circle(circle)
    "#{circle.radius * PI}: #{circle.color}"
  end
end
```</script></section><section data-markdown><script type="text/template">
- e se a gente adicionar mais uma forma? sei l√°, `Triangle`
  - teriamos que adicionar um m√©todo no `Drawer` e modificar o m√©todo `draw`
- e se color retornar algo que n√£o uma string?
- agora *Just imagine* ~~all the people~~ se esse √© um sistema complexo com centenas de entidades que dependem de Square
- o custo de mudan√ßa acaba sendo enorme


<aside class="notes"><ul>
<li>pra resolver esse role o maluco aqui em baixo foi e criou</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
- Bertrand Meyer foi quem coinou o termo, no livro Object Oriented Software Construction (1988!!!)
- O maluco que criou a linguagem *Eiffel* e o conceito de *design by contract*
</script></section><section data-markdown><script type="text/template">
- originalmente a solu√ß√£o pensada pra resolver esse problema foi usando `heran√ßa por implementa√ß√£o`
- uma entidade poderia herdar de um pai um comportamento padr√£o, mas poderia adicionar sua pr√≥pria l√≥gica naquela base
- por√©m depender de classes concretas dificulta a mudan√ßa
</script></section><section data-markdown><script type="text/template">
- Dai veio o Robert C. Martin (titio Bob) com o The Open Closed Principle em 1996 com basicamente dois axiomas
</script></section><section data-markdown><script type="text/template">
> A module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.
</script></section><section data-markdown><script type="text/template">
> A module will be said to be closed if [it] is available for use by other modules. This assumes that the module has been given a well-defined, stable description (the interface in the sense of information hiding)
</script></section><section data-markdown><script type="text/template">
- depois nos anos 90 foi pensado no uso de classes abstratas e interfaces como forma de atingir isso
- v√°rias classes que herdam de uma classe abstrata e que implementam uma interface
  portanto s√£o intercambi√°veis (pois s√£o polim√≥rficas)
</script></section><section data-markdown><script type="text/template">
```ruby
class Shape
  attr_accessor :color

  def draw; "drawing: #{@color}"; end
end

class Circe < Shape
  attr_accessor :radius

  def draw; "#{@radius}: #{@color}"; end
end

class Square < Shape
  attr_accessor :height, :width

  def draw; "#{@height} x #{@width}: #{@color}"; end
end

class Drawer
  def draw(shapes)
    shapes.each do |shape|
      shape.draw
    end
  end
end
```</script></section><section data-markdown><script type="text/template">
- aqui poderiamos adicionar uma classe `Triangle` facilmente, contanto que mantivesse a mesma interface
</script></section></section><section  data-markdown><script type="text/template">
- fazer um m√≥dulo ser open closed √© custoso, abstra√ß√µes s√£o custosas
- abstra√ß√µes (as vezes) s√£o mais dificeis de manter
- abstra√ß√µes incorretas s√£o problem√°ticas
- sempre vai ter uma mudan√ßa que fere o princ√≠pio
</script></section><section  data-markdown><script type="text/template">
Questions? Coisas pra compartilhar? Fala ai
</script></section><section  data-markdown><script type="text/template">
Thanks! üò∏
</script></section><section  data-markdown><script type="text/template">
# EXTRAS
</script></section><section  data-markdown><script type="text/template">
REFS:

- https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle
- https://web.archive.org/web/20060822033314if_/http://www.objectmentor.com:80/resources/articles/ocp.pdf
- http://stg-tud.github.io/sedc/Lecture/ws16-17/3.3-OCP.pdf
</script></section><section  data-markdown><script type="text/template"></script></section></div>
        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: './plugin/zoom-js/zoom.js', async: true },
              { src: './plugin/notes/notes.js', async: true },
              { src: './plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"transition":"slide"};
            options = extend(defaultOptions, options, queryOptions);
        </script>


        <script>
            Reveal.initialize(options);
        </script>
    </body>
</html>
